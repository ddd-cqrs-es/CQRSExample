using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using Contracts;

namespace Domain
{
    public abstract class AggregateRoot
    {
        private readonly List<IEvent> _uncommittedChanges = new List<IEvent>();

        public abstract Guid Id { get; }

        public ReadOnlyCollection<IEvent> GetUncommittedEvents 
        {
            get { return new ReadOnlyCollection<IEvent>(_uncommittedChanges); }
        }

        public void ClearUncommittedEvents()
        {
            _uncommittedChanges.Clear();
        }

        public void LoadsFromHistory(IEnumerable<IEvent> history)
        {
            foreach (var e in history)
            {
                ApplyChange(e, false);
            }
        }

        protected void ApplyChange(IEvent @event)
        {
            ApplyChange(@event, true);
        }

        private void ApplyChange(IEvent @event, bool isNew)
        {
            //NOTE: the use of dynamic here - let the runtime do the work to figure out which method to call
            //NOTE:I have done this for simplicity; I would not recommend releasing this to PROD - there are lots of ways to do this, just Google around
            //Here, we "dispatch" the event to a "When" method on the derived aggregate class - this is where the actual state change happens
            //Applying the event here CAN NOT FAIL - all that should happen is the change in state.
            //If there are any logical statements in the "When" method ("if", "switch", etc) then you are doing it wrong
            //All logic needs to be in the method that handles the command, and the command method should not change the state of the aggregate, but rather raise the event that will get applied here in the base class
            //We have defined a convention here: all methods that apply an event must be called "When" otherwise this code will not find it
            ((dynamic)this).When(@event as dynamic);

            //only record events that are new; ie events generated by processing a command, not loaded from the event store
            if (isNew) 
                _uncommittedChanges.Add(@event);
        }
    }
}
